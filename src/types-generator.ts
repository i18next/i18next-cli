import { mergeResourcesAsInterface } from 'i18next-resources-for-ts'
import { glob } from 'glob'
import ora from 'ora'
import chalk from 'chalk'
import { mkdir, readFile, writeFile, access } from 'node:fs/promises'
import { basename, extname, resolve, dirname, join, relative } from 'node:path'
import type { I18nextToolkitConfig } from './types'
import { getOutputPath } from './utils/file-utils'

/**
 * Represents a translation resource with its namespace name and content
 */
interface Resource {
  /** The namespace name (filename without extension) */
  name: string;
  /** The parsed JSON resources object */
  resources: object;
}

/**
 * Generates TypeScript type definitions for i18next translations.
 *
 * This function:
 * 1. Reads translation files based on the input glob patterns
 * 2. Generates TypeScript interfaces using i18next-resources-for-ts
 * 3. Creates separate resources.d.ts and main i18next.d.ts files
 * 4. Handles namespace detection from filenames
 * 5. Supports type-safe selector API when enabled
 *
 * @param config - The i18next toolkit configuration object
 *
 * @example
 * ```typescript
 * // Configuration
 * const config = {
 *   types: {
 *     input: ['locales/en/*.json'],
 *     output: 'src/types/i18next.d.ts',
 *     enableSelector: true
 *   }
 * }
 *
 * await runTypesGenerator(config)
 * ```
 */
export async function runTypesGenerator (config: I18nextToolkitConfig) {
  const spinner = ora('Generating TypeScript types for translations...\n').start()

  try {
    config.extract.primaryLanguage ||= config.locales[0] || 'en'
    let defaultTypesInputPath = config.extract.output || `locales/${config.extract.primaryLanguage}/*.json`
    defaultTypesInputPath = getOutputPath(defaultTypesInputPath, config.extract.primaryLanguage || 'en', '*')

    if (!config.types) config.types = { input: defaultTypesInputPath, output: 'src/@types/i18next.d.ts' }
    if (config.types.input === undefined) config.types.input = defaultTypesInputPath
    if (!config.types.output) config.types.output = 'src/@types/i18next.d.ts'
    if (!config.types.resourcesFile) config.types.resourcesFile = join(dirname(config.types?.output), 'resources.d.ts')

    if (!config.types?.input || config.types?.input.length < 0) {
      console.log('No input defined!')
      return
    }

    const resourceFiles = await glob(config.types?.input || [], {
      cwd: process.cwd(),
    })

    const resources: Resource[] = []

    for (const file of resourceFiles) {
      const namespace = basename(file, extname(file))
      const content = await readFile(file, 'utf-8')
      const parsedContent = JSON.parse(content)
      resources.push({ name: namespace, resources: parsedContent })
    }

    const logMessages: string[] = []

    const enableSelector = config.types?.enableSelector || false
    const interfaceDefinition = mergeResourcesAsInterface(resources, { optimize: !!enableSelector })
    const outputPath = resolve(process.cwd(), config.types?.output || '')
    const resourcesOutputPath = resolve(process.cwd(), config.types.resourcesFile)
    await mkdir(dirname(resourcesOutputPath), { recursive: true })
    await writeFile(resourcesOutputPath, interfaceDefinition)
    logMessages.push(`  ${chalk.green('✓')} Resources interface written to ${config.types.resourcesFile}`)

    let outputPathExists
    try {
      await access(outputPath)
      outputPathExists = true
    } catch (e) {
      outputPathExists = false
    }

    if (!outputPathExists) {
    // The main output file will now import from the resources file
      const importPath = relative(dirname(outputPath), resourcesOutputPath)
        .replace(/\\/g, '/').replace(/\.d\.ts$/, '') // Make it a valid module path

      const fileContent = `// This file is automatically generated by i18next-cli. Do not edit manually.
import Resources from './${importPath}';

declare module 'i18next' {
  interface CustomTypeOptions {
    enableSelector: ${typeof enableSelector === 'string' ? `"${enableSelector}"` : enableSelector};
    defaultNS: '${config.extract.defaultNS || 'translation'}';
    resources: Resources;
  }
}`
      await mkdir(dirname(outputPath), { recursive: true })
      await writeFile(outputPath, fileContent)
      logMessages.push(`  ${chalk.green('✓')} TypeScript definitions written to ${config.types.output || ''}`)
    }
    spinner.succeed(chalk.bold('TypeScript definitions generated successfully.'))
    logMessages.forEach(msg => console.log(msg))
  } catch (error) {
    spinner.fail(chalk.red('Failed to generate TypeScript definitions.'))
    console.error(error)
  }
}
