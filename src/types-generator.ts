import { mergeResourcesAsInterface } from 'i18next-resources-for-ts'
import { glob } from 'glob'
import ora from 'ora'
import chalk from 'chalk'
import { mkdir, readFile, writeFile, access } from 'node:fs/promises'
import { basename, extname, resolve, dirname, join, relative } from 'node:path'
import { transform } from '@swc/core'
import type { I18nextToolkitConfig } from './types'
import { getOutputPath } from './utils/file-utils'
import vm from 'node:vm'

/**
 * Represents a translation resource with its namespace name and content
 */
interface Resource {
  /** The namespace name (filename without extension) */
  name: string;
  /** The parsed JSON resources object */
  resources: object;
}

async function loadFile (file: string) {
  const ext = extname(file)
  if (['.ts', '.mts', '.cts', '.js', '.mjs', '.cjs'].includes(ext)) {
    const content = await readFile(file, 'utf-8')

    const { code } = await transform(content, {
      filename: file,
      jsc: {
        parser: {
          syntax: 'typescript',
        },
        target: 'es2018'
      },
      module: {
        type: 'commonjs'
      }
    })

    const context = vm.createContext({
      exports: {},
      module: { exports: {} },
      require: (id: string) => require(id),
      console,
      process
    })

    const script = new vm.Script(code, { filename: file })
    script.runInContext(context)

    // @ts-ignore
    const exported = context.module.exports?.default || context.module.exports
    return exported
  }

  const content = await readFile(file, 'utf-8')
  return JSON.parse(content)
}

/**
 * Generates TypeScript type definitions for i18next translations.
 *
 * This function:
 * 1. Reads translation files based on the input glob patterns
 * 2. Generates TypeScript interfaces using i18next-resources-for-ts
 * 3. Creates separate resources.d.ts and main i18next.d.ts files
 * 4. Handles namespace detection from filenames
 * 5. Supports type-safe selector API when enabled
 *
 * @param config - The i18next toolkit configuration object
 *
 * @example
 * ```typescript
 * // Configuration
 * const config = {
 *   types: {
 *     input: ['locales/en/*.json'],
 *     output: 'src/types/i18next.d.ts',
 *     enableSelector: true
 *   }
 * }
 *
 * await runTypesGenerator(config)
 * ```
 */
export async function runTypesGenerator (config: I18nextToolkitConfig) {
  const spinner = ora('Generating TypeScript types for translations...\n').start()

  try {
    config.extract.primaryLanguage ||= config.locales[0] || 'en'
    let defaultTypesInputPath = config.extract.output || `locales/${config.extract.primaryLanguage}/*.json`
    defaultTypesInputPath = getOutputPath(defaultTypesInputPath, config.extract.primaryLanguage || 'en', '*')

    if (!config.types) config.types = { input: defaultTypesInputPath, output: 'src/@types/i18next.d.ts' }
    if (config.types.input === undefined) config.types.input = defaultTypesInputPath
    if (!config.types.output) config.types.output = 'src/@types/i18next.d.ts'
    if (!config.types.resourcesFile) config.types.resourcesFile = join(dirname(config.types?.output), 'resources.d.ts')

    if (!config.types?.input || config.types?.input.length < 0) {
      console.log('No input defined!')
      return
    }

    const resourceFiles = await glob(config.types?.input || [], {
      cwd: process.cwd(),
    })

    const resources: Resource[] = []

    for (const file of resourceFiles) {
      const namespace = basename(file, extname(file))
      const parsedContent = await loadFile(file)

      // If mergeNamespaces is used, a single file can contain multiple namespaces
      // (e.g. { "translation": { ... }, "common": { ... } } in a per-language file).
      // In that case, expose each top-level key as a namespace entry so the type
      // generator will produce top-level namespace interfaces (not a language wrapper).
      if (config.extract?.mergeNamespaces && parsedContent && typeof parsedContent === 'object') {
        const keys = Object.keys(parsedContent)
        const allObjects = keys.length > 0 && keys.every(k => parsedContent[k] && typeof parsedContent[k] === 'object')
        if (allObjects) {
          for (const nsName of keys) {
            resources.push({ name: nsName, resources: parsedContent[nsName] })
          }
          continue
        }
      }

      resources.push({ name: namespace, resources: parsedContent })
    }

    const logMessages: string[] = []

    const enableSelector = config.types?.enableSelector || false
    const indentation = config.types?.indentation ?? config.extract.indentation ?? 2
    const interfaceDefinition = `// This file is automatically generated by i18next-cli. Do not edit manually.
${mergeResourcesAsInterface(resources, { optimize: !!enableSelector, indentation })}`

    const outputPath = resolve(process.cwd(), config.types?.output || '')
    const resourcesOutputPath = resolve(process.cwd(), config.types.resourcesFile)
    await mkdir(dirname(resourcesOutputPath), { recursive: true })
    await writeFile(resourcesOutputPath, interfaceDefinition)
    logMessages.push(`  ${chalk.green('✓')} Resources interface written to ${config.types.resourcesFile}`)

    let outputPathExists
    try {
      await access(outputPath)
      outputPathExists = true
    } catch (e) {
      outputPathExists = false
    }

    if (!outputPathExists) {
    // The main output file will now import from the resources file
      const importPath = relative(dirname(outputPath), resourcesOutputPath)
        .replace(/\\/g, '/').replace(/\.d\.ts$/, '') // Make it a valid module path

      const fileContent = `// This file is automatically generated by i18next-cli, because it was not existing. You can edit it based on your needs: https://www.i18next.com/overview/typescript#custom-type-options
import Resources from './${importPath}';

declare module 'i18next' {
  interface CustomTypeOptions {
    enableSelector: ${typeof enableSelector === 'string' ? `"${enableSelector}"` : enableSelector};
    defaultNS: '${config.extract.defaultNS || 'translation'}';
    resources: Resources;
  }
}`
      await mkdir(dirname(outputPath), { recursive: true })
      await writeFile(outputPath, fileContent)
      logMessages.push(`  ${chalk.green('✓')} TypeScript definitions written to ${config.types.output || ''}`)
    }
    spinner.succeed(chalk.bold('TypeScript definitions generated successfully.'))
    logMessages.forEach(msg => console.log(msg))
  } catch (error) {
    spinner.fail(chalk.red('Failed to generate TypeScript definitions.'))
    console.error(error)
  }
}
